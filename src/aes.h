#pragma once
#include "nap_common.h"
#include "btring.h"
_NAP_BEGIN

//矩阵转换 
#define char2matrix4x4(out,in)\
	(out)[0] =  (in)[0];(out)[4] =  (in)[1];(out)[8] =  (in)[2];(out)[12] = (in)[3];\
	(out)[1] =  (in)[4];(out)[5] =  (in)[5];(out)[9] =  (in)[6];(out)[13] = (in)[7];\
	(out)[2] =  (in)[8];(out)[6] =  (in)[9];(out)[10] = (in)[10];(out)[14] = (in)[11];\
	(out)[3] =  (in)[12];(out)[7] =  (in)[13];(out)[11] = (in)[14];(out)[15] = (in)[15];

#define SWAP(a,b) (((a)^=(b)),((b)^=(a)),((a)^=(b)))

#define INT32(a,b,c,d) ((((uint32_t)(a))<<24)|(((uint32_t)(b))<<16)|(((uint32_t)(c))<<8)|((uint32_t)(d)))

#define INT32TOCHAR(dst, src)\
	(dst)[0] = ((src) >> 24) & 0xff; \
	(dst)[1] = ((src) >> 16) & 0xff; \
	(dst)[2] = ((src) >> 8)  & 0xff; \
	(dst)[3] = (src)        & 0xff;


#define U64TOCHAR(chars,val)\
	(chars)[0] = (uint8_t)(val >> 56);\
	(chars)[1] = (uint8_t)(val >> 48);\
	(chars)[2] = (uint8_t)(val >> 40);\
	(chars)[3] = (uint8_t)(val >> 32);\
	(chars)[4] = (uint8_t)(val >> 24);\
	(chars)[5] = (uint8_t)(val >> 16);\
	(chars)[6] = (uint8_t)(val >> 8 );\
	(chars)[7] = (uint8_t)(val & 0xff);


typedef const char* Key;
typedef uint8_t* Matrix4x4;

enum class AesPaddingType {
	PKCS5, PKCS7,	//填充填充数
	ISO10126,		//最后一位填充填充数，其余随机
	Zeros,			//0填充解密时不会自动去除
	None,			//不填充
};

class AesKey {
public:

	enum class Type : uint32_t {
		T_128 = 4, //44
		T_192 = 6, //52
		T_256 = 8  //60
	};
	Type type;

	AesKey(const char* key, size_t length);
	AesKey(const char* key, Type);
	AesKey(const btring& key, Type);
	AesKey(AesKey&&) noexcept;
	AesKey(const AesKey&);
	~AesKey();
	uint32_t round() const;
	inline uint32_t* getKey() const { return _keys_e; }
	inline uint32_t* getDKey() const { return _keys_d; }
private:
	void _init(const char* key, Type _type);
	void _key_expansion(const uint8_t* key);

	//word of number(array length) : Nb (Nr + 1) = 44,52,60
	uint32_t* _keys_e = nullptr;
	uint32_t* _keys_d = nullptr;

	uint32_t _array_length = 0; //Nb (Nr + 1) = 44,52,60
};

template<uint32_t BIT>
class CryptIV {
public:

	CryptIV(const char* iv) {
		assert(BIT % 8 == 0);	//The length must be a multiple of eight 
		assert(BIT != 0);		//Length cannot be zero 
		btring _iv(iv, BIT / 8);
		this->set(_iv);
	}

	CryptIV() {
		assert(BIT % 8 == 0);	//The length must be a multiple of eight 
		assert(BIT != 0);		//Length cannot be zero 
		this->_iv.fill('\0', BIT);
	}

	CryptIV& operator++(int) {
		uint8_t* buf = this->_iv.str();
		bool flag = false;
		const int bytes = BIT / 8;

		for (int i = bytes - 1; i >= 0; i--) {
			if (i == bytes - 1) {
				if (buf[i] == 0xff) {
					buf[i] = 0;
					flag = true;
				} else {
					buf[i]++;
					break;
				}
				continue;
			}
			if (flag) {
				if (buf[i] == 0xff) {
					buf[i] = 0;
					flag = true;
					continue;
				} else {
					buf[i]++;
					flag = false;
					break;
				}
			} else {
				break;
			}
		}
		return *this;
	}
	void set(btring iv) {
		this->_iv = iv;
	}
	btring& get() { return this->_iv; };

private:
	btring _iv;
};

typedef CryptIV<128> AesIV;
typedef CryptIV<96> AesGCMIV;



//Galois Multiplication lookup tables

const static uint8_t gm_2[]{
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
	0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
	0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
	0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
	0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
	0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
	0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
	0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
	0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
	0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
	0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
	0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
	0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
	0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
	0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
	0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5,
};

const static uint8_t gm_3[]{
	0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
	0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
	0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
	0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
	0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
	0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
	0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
	0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
	0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
	0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
	0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
	0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
	0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
	0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
	0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
	0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a,
};

const static uint8_t gm_9[]{
	0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
	0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
	0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
	0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
	0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
	0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
	0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
	0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
	0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
	0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
	0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
	0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
	0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
	0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
	0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
	0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46
};

const static uint8_t gm_B[]{
	0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
	0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
	0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
	0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
	0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
	0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
	0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
	0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
	0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
	0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
	0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
	0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
	0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
	0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
	0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
	0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3,
};

const static uint8_t gm_D[]{
	0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
	0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
	0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
	0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
	0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
	0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
	0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
	0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
	0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
	0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
	0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
	0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
	0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
	0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
	0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
	0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97
};

const static uint8_t gm_E[]{
	0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
	0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
	0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
	0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
	0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
	0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
	0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
	0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
	0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
	0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
	0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
	0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
	0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
	0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
	0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
	0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d
};


static const uint32_t aes_rcon[11] = {
		0x01000000UL,0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL,
		0x10000000UL,0x20000000UL, 0x40000000UL, 0x80000000UL, 0x1B000000UL,
		0x36000000UL
};
const static uint8_t aes_s_box[256] = {
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};
const static uint8_t aes_inv_s_box[256] = {
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};


class AesFun {
public:

	

	//字节替换 1
	static void subbytes(uint8_t* matrix4x4) {//通过S-BOX 进行非线性替代
		for (int i = 0; i < 16; i++)
			matrix4x4[i] =
			aes_s_box[matrix4x4[i]];
	}
	static void invsubbytes(uint8_t* matrix4x4) {
		for (int i = 0; i < 16; i++)
			matrix4x4[i] =
			aes_inv_s_box[matrix4x4[i]];
	}

	//行移位 2
	static void leftshift_1(uint8_t* matrix1x4) {
		uint8_t a = matrix1x4[0];
		matrix1x4[0] = matrix1x4[1];
		matrix1x4[1] = matrix1x4[2];
		matrix1x4[2] = matrix1x4[3];
		matrix1x4[3] = a;
	}
	static void leftshift_2(uint8_t* matrix1x4) {
		uint8_t a = matrix1x4[0];
		matrix1x4[0] = matrix1x4[2];
		matrix1x4[2] = a;
		a = matrix1x4[1];
		matrix1x4[1] = matrix1x4[3];
		matrix1x4[3] = a;
	}
	static void rightshift_1(uint8_t* matrix1x4) {
		uint8_t a = matrix1x4[0];
		matrix1x4[0] = matrix1x4[3];
		matrix1x4[3] = matrix1x4[2];
		matrix1x4[2] = matrix1x4[1];
		matrix1x4[1] = a;
	}

	static void shiftrows(uint8_t* matrix4x4) {
		leftshift_1(matrix4x4 + 4);
		leftshift_2(matrix4x4 + 8);
		rightshift_1(matrix4x4 + 12); //leftshift_3(matrix4x4 + 12);
	}
	static void invshiftrows(uint8_t* matrix4x4) {
		rightshift_1(matrix4x4 + 4);
		leftshift_2(matrix4x4 + 8); //rightshift_2(matrix4x4 + 8);
		leftshift_1(matrix4x4 + 12); //rightshift_3(matrix4x4 + 12);
	}

	//列混淆 3
	static void mixcolumns(uint8_t* matrix4x4) {
		uint8_t arr[4];
		for (int i = 0; i < 4; ++i)
		{
			for (int j = 0; j < 4; ++j)
				arr[j] = matrix4x4[i + j * 4];

			matrix4x4[i] = gm_2[arr[0]] ^ gm_3[arr[1]] ^ arr[2] ^ arr[3];
			matrix4x4[i + 4] = arr[0] ^ gm_2[arr[1]] ^ gm_3[arr[2]] ^ arr[3];
			matrix4x4[i + 8] = arr[0] ^ arr[1] ^ gm_2[arr[2]] ^ gm_3[arr[3]];
			matrix4x4[i + 12] = gm_3[arr[0]] ^ arr[1] ^ arr[2] ^ gm_2[arr[3]];
		}
	}
	static void invmixcolumns(uint8_t* matrix4x4) {
		uint8_t arr[4];
		for (int i = 0; i < 4; ++i)
		{
			for (int j = 0; j < 4; ++j)
				arr[j] = matrix4x4[i + j * 4];

			matrix4x4[i] = gm_E[arr[0]] ^ gm_B[arr[1]] ^ gm_D[arr[2]] ^ gm_9[arr[3]];
			matrix4x4[i + 4] = gm_9[arr[0]] ^ gm_E[arr[1]] ^ gm_B[arr[2]] ^ gm_D[arr[3]];
			matrix4x4[i + 8] = gm_D[arr[0]] ^ gm_9[arr[1]] ^ gm_E[arr[2]] ^ gm_B[arr[3]];
			matrix4x4[i + 12] = gm_B[arr[0]] ^ gm_D[arr[1]] ^ gm_9[arr[2]] ^ gm_E[arr[3]];
		}
	}

	//轮密钥加 4
	static void addroundkey(uint8_t* matrix4x4, uint32_t* _4rkey) {
		for (int x = 0; x < 4; x++) {
			uint32_t key = *_4rkey;
			matrix4x4[0 * 4 + x] ^= uint8_t((key & 0xff000000) >> 24);
			matrix4x4[1 * 4 + x] ^= uint8_t((key & 0x00ff0000) >> 16);
			matrix4x4[2 * 4 + x] ^= uint8_t((key & 0x0000ff00) >> 8);
			matrix4x4[3 * 4 + x] ^= uint8_t((key & 0x000000ff));
			_4rkey++;
		}
	}

	//16byte加解密(单块加解密)
	static void encrypt_block(Matrix4x4 matrix4x4, const AesKey& key) {
		uint32_t* rk = key.getKey();
		AesFun::addroundkey(matrix4x4, rk);
		for (uint32_t j = 1; j < key.round(); ++j) {
			rk += 4;
			AesFun::subbytes(matrix4x4);   // 字节替换
			AesFun::shiftrows(matrix4x4);  // 行移位
			AesFun::mixcolumns(matrix4x4); // 列混合
			AesFun::addroundkey(matrix4x4, rk); // 轮秘钥加
		}
		AesFun::subbytes(matrix4x4);    // 字节替换
		AesFun::shiftrows(matrix4x4);  // 行移位
		// 此处不进行列混合
		AesFun::addroundkey(matrix4x4, rk + 4);
	}
	static void decrypt_block(Matrix4x4 matrix4x4, const AesKey& key) {
		uint32_t* rk = key.getDKey();
		AesFun::addroundkey(matrix4x4, rk);
		for (uint32_t j = 1; j < key.round(); ++j) {
			rk += 4;
			AesFun::invshiftrows(matrix4x4);  // 行移位
			AesFun::invsubbytes(matrix4x4);   // 字节替换
			AesFun::addroundkey(matrix4x4, rk); // 轮秘钥加
			AesFun::invmixcolumns(matrix4x4); // 列混合
		}
		AesFun::invsubbytes(matrix4x4);    // 字节替换
		AesFun::invshiftrows(matrix4x4);  // 行移位
		// 此处不进行列混合
		AesFun::addroundkey(matrix4x4, rk + 4);
	}

	//伽罗华域乘法
	static void g_num128(const uint8_t* x,const uint8_t* y , uint8_t* ret); //128位
	

	//128位右移
	static void shift_right_block(uint8_t* v);

	//128位异或
	static void xor_128block(uint8_t* dst, const uint8_t* src);

};

class AesPadding {
protected:

	AesPadding(AesPaddingType t) :_padding_type(t) {};

	//len并非是buf的长度，而是buf的有效长度。buf固定为16字节。函数添加填充并返回填充长度
	int addPadding(char* buf, uint8_t len);

	//len是buf的长度，和addPadding不同,返回填充长度却不对填充进行操作
	int removePadding(char* buf, uint8_t len);

private:
	AesPaddingType _padding_type;
};

template<typename TRet>
class AesBuffer{
public:

	void add(const btring& b) { this->add((const char*)b.str(), b.size()); };
	void add(const char*,size_t);

	//end表示结束数据的输入。
	
	TRet end() { TRet ret = this->endinput(_buffer, _buffer_len); this->reset(); return ret; };
	void reset() { _buffer_len = 0; this->_result = ""; this->resetdata(); };

protected:
	AesBuffer() {};

	/*
		_buffer 用于存储因为不足16byte而无法处理的数据
		_buffer_len 指定_buffer中有效数据的长度
	*/
	uint8_t _buffer[16] = {};
	size_t _buffer_len = 0;
	btring _result; //_result 存储计算后的结果


	//处理一个或多个16Byte数据块
	virtual void handle(const char*,char*, size_t) = 0;

	//结束输入，输出结果。（这两个参数对部分解密无意义，仅用于加密填充和流式解密）
	virtual TRet endinput(uint8_t*,uint8_t) = 0;

	//重置数据到最后一次调用endinput之后
	virtual void resetdata() = 0;

};

class AesECBEncryption : public AesBuffer<btring> , public AesPadding {
public:
	AesECBEncryption(AesKey key, AesPaddingType t = AesPaddingType::PKCS7);

protected:

	AesKey _key;

	virtual void handle(const char* buf, char* out, size_t len);
	virtual btring endinput(uint8_t* buf, uint8_t len);
	virtual void resetdata() {};

};

class AesECBDecryption : public AesECBEncryption{
public:
	AesECBDecryption(AesKey key, AesPaddingType t = AesPaddingType::PKCS7);

protected:

	virtual void handle(const char* buf, char* out, size_t len);

	virtual btring endinput(uint8_t*, uint8_t);

	virtual void resetdata() {};
};

class AesCBCEncryption : public AesBuffer<btring>, public AesPadding {
public:
	AesCBCEncryption(AesKey key, AesIV iv, AesPaddingType t = AesPaddingType::PKCS7);
	void setIV(AesIV iv) { this->_iv = iv; }
	AesIV getIV() { return this->_iv; }

protected:
	AesKey _key;
	AesIV _iv;
	AesIV _original_iv;

	virtual void handle(const char* buf, char* out, size_t len);

	virtual btring endinput(uint8_t* buf, uint8_t len);

	virtual void resetdata();
};

class AesCBCDecryption : public AesCBCEncryption {
public:
	AesCBCDecryption(AesKey key, AesIV iv, AesPaddingType t = AesPaddingType::PKCS7);

protected:

	virtual void handle(const char* buf, char* out, size_t len);
	virtual btring endinput(uint8_t*, uint8_t);

};

class AesCTREncryption : public AesBuffer<btring> {
public:
	AesCTREncryption(AesKey key, AesIV counter);

	void setCounter(AesIV counter) { this->_counter = counter; }
	AesIV getCounter() { return this->_counter; }

protected:
	AesKey _key;
	AesIV _counter;
	AesIV _original_counter;

	virtual void handle(const char* buf, char* out, size_t len);

	virtual btring endinput(uint8_t* buf, uint8_t len);

	virtual void resetdata();
};

class AesCTRDecryption : public AesCTREncryption {
public:
	AesCTRDecryption(AesKey key, AesIV counter)
		:AesCTREncryption(key, counter) {
	};

};

class AesGCMEncryption : public AesBuffer<std::pair<btring,btring>>{
public:

	AesGCMEncryption(AesKey key, AesGCMIV iv, btring aad);

protected:
	btring _aad;//const
	AesKey _key;//const
	AesGCMIV _original_iv;
	AesGCMIV _iv;
	uint8_t H[16] = { 0 };// const
	
	uint8_t J0[16] = {0}; //temp
	uint8_t J0_begin[16] = {0}; //temp,用于最后计算tag
	uint8_t S[16] = {0}; //tag's temp var
	
	//Internal function 
	void encrypt_block(const uint8_t* plain, uint8_t* crypt);
	void calculate_j0();
	void inc32(uint8_t* block);
	void gctr(const char* in, char* out, size_t len);
	void ghash(const uint8_t* x, size_t xlen);

	//Inherited function 
	virtual void handle(const char* buf, char* out, size_t len);
	virtual std::pair<btring, btring> endinput(uint8_t* buf, uint8_t len);
	virtual void resetdata();
};

class AesGCMDecryption : public AesGCMEncryption {
public:
	AesGCMDecryption(AesKey key, AesGCMIV iv, btring aad);

protected:

	virtual void handle(const char* buf, char* out, size_t len);
	virtual std::pair<btring, btring> endinput(uint8_t* buf, uint8_t len);
};

enum CryptoMode 
{
	CBC_Mode,
	CTR_Mode,
	ECB_Mode,
	GCM_Mode
};

template<CryptoMode M>
class AES {
private:
	AES() {};
};

template<>
class AES<ECB_Mode> {
public:
	typedef AesECBEncryption Encryption;
	typedef AesECBDecryption Decryption;
};

template<>
class AES<CBC_Mode> {
public:
	typedef AesCBCEncryption Encryption;
	typedef AesCBCDecryption Decryption;
};

template<>
class AES<CTR_Mode> {
public:
	typedef AesCTREncryption Encryption;
	typedef AesCTRDecryption Decryption;
};

template<>
class AES<GCM_Mode> {
public:
	typedef AesGCMEncryption Encryption;
	typedef AesGCMDecryption Decryption;
};

template<typename TRet>
void AesBuffer<TRet>::add(const char* data, size_t data_len) {
	if (_buffer_len == 0) {
		//没有待处理数据，直接处理参数传递的数据
		if (data_len < 16) {
			memcpy(_buffer, data, data_len);
			_buffer_len = data_len;
		} else {
			size_t max_deal = data_len - (data_len % 16);
			this->_result.resize(this->_result.size() + max_deal);
			this->handle(data,
				(char*)this->_result.str() + this->_result.size() - max_deal,
				max_deal);
			if (max_deal != data_len) {
				_buffer_len = data_len - max_deal;
				memcpy(_buffer, data + max_deal, _buffer_len);
			}
			return;
		}
	} else {
		//先处理拼凑待处理的数据然后在处理缓冲区
		if (_buffer_len + data_len < 16) {
			memcpy(_buffer + _buffer_len, data, data_len);
			_buffer_len += data_len;
		} else {
			uint32_t rent_length = 16 - (uint32_t)_buffer_len;
			memcpy(_buffer + _buffer_len, data, rent_length);
			_buffer_len = 0;
			this->handle((char*)_buffer, (char*)_buffer, 16);
			this->_result.append(_buffer, 16);
			data += rent_length;
			data_len -= rent_length;
			this->add((const char*)data, data_len);
		}
		return;
	}
}




_NAP_END